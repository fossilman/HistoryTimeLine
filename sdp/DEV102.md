# History Timezone 开发文档

## 1. 文档说明

### 1.1 文档目的
本文档旨在为 History Timezone 项目提供完整的技术实现指导，包括系统架构、数据库设计、API 接口规范和前端实现方案。本文档面向开发团队，用于指导 MVP 版本的开发工作。

### 1.2 文档范围
- 系统整体架构设计
- MySQL 数据库表结构与索引设计
- RESTful API 接口定义
- 前端组件架构与交互实现
- 核心算法实现（无极缩放、轨道分配）
- 性能优化方案

### 1.3 参考文档
- 《History Timezone 产品需求文档 v1.2》
- D3.js Zoom Behavior 文档
- Canvas API 规范
- React Performance Optimization Best Practices

---

## 2. 系统架构设计

### 2.1 整体架构

```
┌─────────────────────────────────────────────────────┐
│                   Browser Client                     │
│  ┌───────────────────────────────────────────────┐  │
│  │          React Application Layer              │  │
│  │  ├─ Timeline Canvas Renderer                  │  │
│  │  ├─ Zoom & Pan Controller                     │  │
│  │  ├─ State Management (Redux)                  │  │
│  │  ├─ Track Assignment Engine                   │  │
│  │  └─ UI Components                             │  │
│  └───────────────────────────────────────────────┘  │
└──────────────────────┬──────────────────────────────┘
                       │ HTTPS/REST API
┌──────────────────────▼──────────────────────────────┐
│              Node.js Backend Server                  │
│  ┌───────────────────────────────────────────────┐  │
│  │          Express.js API Layer                 │  │
│  │  ├─ Timeline Data Service                     │  │
│  │  ├─ Range Query Optimizer                     │  │
│  │  ├─ Response Cache (Memory)                   │  │
│  │  └─ Error Handler & Logger                    │  │
│  └───────────────────────────────────────────────┘  │
└──────────────────────┬──────────────────────────────┘
                       │
┌──────────────────────▼──────────────────────────────┐
│                    MySQL Database                    │
│  ├─ civilizations (文明表)                          │
│  ├─ polities (政权表)                               │
│  ├─ persons (人物表)                                │
│  ├─ events (事件表)                                 │
│  └─ B-Tree Indexes (年份范围索引)                   │
└─────────────────────────────────────────────────────┘
```

**架构特点**：
- **前后端分离**：React SPA + Node.js RESTful API
- **Canvas 渲染**：使用 Canvas 处理大量图形元素，提升渲染性能
- **状态管理**：Redux 管理全局状态（缩放级别、视窗范围、数据缓存）
- **内存缓存**：Node.js 内存缓存常用查询结果，减少数据库压力
- **虚拟化渲染**：仅渲染当前视窗内的元素
- **智能查询**：基于视窗跨度智能查询不同密度的数据

---

### 2.2 技术栈选择

#### 2.2.1 前端技术栈
- **框架**：React 18.x
- **状态管理**：Redux Toolkit + RTK Query
- **渲染引擎**：HTML5 Canvas API
- **动画库**：自研基于 `requestAnimationFrame` 的缩放动画
- **构建工具**：Vite 5.x
- **样式方案**：Tailwind CSS 3.x + CSS Modules
- **类型检查**：TypeScript 5.x
- **HTTP 客户端**：Axios

**技术选型理由**：
- React：组件化开发，生态成熟，适合复杂交互
- Canvas：处理大量图形元素性能优异，支持 60fps 流畅缩放
- Redux：复杂状态管理，支持时间旅行调试
- TypeScript：类型安全，降低运行时错误
- Vite：快速的开发服务器和构建工具

#### 2.2.2 后端技术栈
- **运行时**：Node.js 20.x LTS
- **框架**：Express.js 4.x
- **ORM**：Sequelize 6.x（支持 MySQL）
- **验证库**：Joi
- **日志**：Winston
- **进程管理**：PM2

**技术选型理由**：
- Express.js：轻量级，灵活，中间件生态丰富
- Sequelize：成熟的 ORM，支持 MySQL，提供强大的查询构建器
- Joi：强大的数据验证库
- Winston：灵活的日志系统

#### 2.2.3 数据库
- **主库**：MySQL 8.0+
  - 支持复杂的范围查询和 B-Tree 索引
  - 事务支持保证数据一致性
  - JSON 类型支持灵活的元数据存储
  - 广泛使用，运维成熟

**MySQL 选型理由**：
- 成熟稳定，社区活跃
- 优秀的范围查询性能（B-Tree 索引）
- 事务支持保证数据完整性
- 运维工具丰富

---

## 3. 数据库设计

### 3.1 数据库概述
- **数据库类型**：MySQL 8.0+
- **字符集**：utf8mb4（支持完整 Unicode）
- **排序规则**：utf8mb4_unicode_ci
- **时区**：UTC
- **命名规范**：snake_case
- **主键策略**：VARCHAR(36) UUID

### 3.2 数据表设计

#### 3.2.1 civilizations（文明表）

```sql
CREATE TABLE civilizations (
    id VARCHAR(36) PRIMARY KEY COMMENT '主键UUID',
    name VARCHAR(100) NOT NULL UNIQUE COMMENT '文明名称',
    start_year INT NOT NULL COMMENT '起始年份（负数表示公元前）',
    end_year INT DEFAULT NULL COMMENT '结束年份（NULL表示持续至今）',
    color VARCHAR(7) NOT NULL COMMENT 'HEX颜色值 #RRGGBB',
    description TEXT COMMENT '文明描述',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
    
    CONSTRAINT chk_year_range CHECK (end_year IS NULL OR end_year > start_year),
    INDEX idx_year_range (start_year, end_year)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='文明表';
```

**字段说明**：
- `id`：主键，UUID 格式
- `name`：文明名称，唯一约束
- `start_year`：起始年份（负数表示公元前，如 -2000 表示公元前2000年）
- `end_year`：结束年份，NULL 表示持续至今
- `color`：可视化配色，HEX 格式
- `description`：文明详细描述
- **索引**：`idx_year_range` 加速年份范围查询

---

#### 3.2.2 polities（政权表）

```sql
CREATE TABLE polities (
    id VARCHAR(36) PRIMARY KEY COMMENT '主键UUID',
    name VARCHAR(100) NOT NULL COMMENT '政权名称',
    civilization_id VARCHAR(36) NOT NULL COMMENT '所属文明ID',
    start_year INT NOT NULL COMMENT '起始年份',
    end_year INT NOT NULL COMMENT '结束年份',
    color VARCHAR(7) NOT NULL COMMENT 'HEX颜色值',
    importance ENUM('high', 'medium', 'low') NOT NULL DEFAULT 'medium' COMMENT '重要程度',
    description TEXT COMMENT '政权描述',
    duration INT GENERATED ALWAYS AS (end_year - start_year) STORED COMMENT '存续时间（虚拟列）',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    CONSTRAINT fk_polity_civilization FOREIGN KEY (civilization_id) 
        REFERENCES civilizations(id) ON DELETE CASCADE,
    CONSTRAINT chk_polity_year_range CHECK (end_year > start_year),
    
    INDEX idx_civilization (civilization_id),
    INDEX idx_year_range (start_year, end_year),
    INDEX idx_importance_duration (importance, duration)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='政权表';
```

**字段说明**：
- `civilization_id`：外键关联 civilizations 表
- `importance`：重要程度，用于筛选显示（视窗跨度 > 2000年时仅显示 high）
- `duration`：存续时间，虚拟列，用于筛选长期政权
- **索引**：
  - `idx_civilization`：按文明查询
  - `idx_year_range`：年份范围查询
  - `idx_importance_duration`：重要程度和存续时间联合索引

---

#### 3.2.3 persons（人物表）

```sql
CREATE TABLE persons (
    id VARCHAR(36) PRIMARY KEY COMMENT '主键UUID',
    name VARCHAR(100) NOT NULL COMMENT '人物姓名',
    birth_year INT NOT NULL COMMENT '出生年份',
    death_year INT NOT NULL COMMENT '逝世年份',
    polity_id VARCHAR(36) NOT NULL COMMENT '所属政权ID',
    civilization_id VARCHAR(36) NOT NULL COMMENT '所属文明ID',
    importance ENUM('high', 'medium', 'low') NOT NULL DEFAULT 'medium' COMMENT '重要程度',
    title VARCHAR(100) COMMENT '主要头衔/身份',
    brief_intro TEXT COMMENT '简要介绍',
    lifespan INT GENERATED ALWAYS AS (death_year - birth_year) STORED COMMENT '寿命（虚拟列）',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    CONSTRAINT fk_person_polity FOREIGN KEY (polity_id) 
        REFERENCES polities(id) ON DELETE CASCADE,
    CONSTRAINT fk_person_civilization FOREIGN KEY (civilization_id) 
        REFERENCES civilizations(id) ON DELETE CASCADE,
    CONSTRAINT chk_person_year_range CHECK (death_year > birth_year),
    
    INDEX idx_polity (polity_id),
    INDEX idx_civilization (civilization_id),
    INDEX idx_year_range (birth_year, death_year),
    INDEX idx_importance (importance)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='人物表';
```

**字段说明**：
- `birth_year`、`death_year`：生卒年份，构成人物的时间区间
- `polity_id`：所属政权
- `civilization_id`：所属文明（冗余字段，便于查询）
- `importance`：重要程度（视窗跨度 < 100年显示 high，< 30年显示全部）
- `title`：主要身份（如"皇帝"、"思想家"）
- **索引**：支持按政权、文明、年份范围、重要程度查询

---

#### 3.2.4 events（事件表）

```sql
CREATE TABLE events (
    id VARCHAR(36) PRIMARY KEY COMMENT '主键UUID',
    name VARCHAR(200) NOT NULL COMMENT '事件名称',
    type ENUM('point', 'duration') NOT NULL COMMENT '事件类型：瞬时/持续',
    year INT DEFAULT NULL COMMENT '事件年份（瞬时事件）',
    start_year INT DEFAULT NULL COMMENT '起始年份（持续事件）',
    end_year INT DEFAULT NULL COMMENT '结束年份（持续事件）',
    importance ENUM('high', 'medium', 'low') NOT NULL DEFAULT 'medium' COMMENT '重要程度',
    description TEXT COMMENT '事件描述',
    related_polities JSON COMMENT '相关政权ID数组',
    related_persons JSON COMMENT '相关人物ID数组',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    CONSTRAINT chk_event_type CHECK (
        (type = 'point' AND year IS NOT NULL AND start_year IS NULL AND end_year IS NULL) OR
        (type = 'duration' AND year IS NULL AND start_year IS NOT NULL AND end_year IS NOT NULL)
    ),
    CONSTRAINT chk_duration_range CHECK (
        type = 'point' OR (end_year > start_year)
    ),
    
    INDEX idx_type (type),
    INDEX idx_year (year),
    INDEX idx_year_range (start_year, end_year),
    INDEX idx_importance (importance)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='事件表';
```

**字段说明**：
- `type`：事件类型
  - `point`：瞬时事件，使用 `year` 字段
  - `duration`：持续事件，使用 `start_year` 和 `end_year`
- `related_polities`：JSON 数组，存储相关政权 ID
- `related_persons`：JSON 数组，存储相关人物 ID
- **约束**：
  - `chk_event_type`：确保瞬时事件和持续事件字段正确
  - `chk_duration_range`：持续事件结束年份必须大于起始年份
- **索引**：支持按类型、年份、年份范围、重要程度查询

---

#### 3.2.5 数据库关系图

```
civilizations (1) ──────────┐
    │                       │
    │ (1:N)                 │ (1:N)
    │                       │
    ▼                       ▼
polities (N) ───────► persons (N)
    │                       
    │ (关联关系通过 JSON)   
    │                       
    ▼                       
events (N)
```

---

## 4. API 接口设计

### 4.1 API 设计规范

#### 4.1.1 基础规范
- **协议**：HTTPS
- **风格**：RESTful
- **版本**：URL 路径版本控制 `/api/v1/`
- **请求格式**：`application/json`
- **响应格式**：`application/json`
- **字符编码**：UTF-8

#### 4.1.2 HTTP 方法
- `GET`：查询资源
- `POST`：创建资源
- `PUT`：完整更新资源
- `PATCH`：部分更新资源
- `DELETE`：删除资源

#### 4.1.3 状态码规范
| 状态码 | 说明 |
|--------|------|
| 200 | 请求成功 |
| 201 | 创建成功 |
| 400 | 请求参数错误 |
| 404 | 资源不存在 |
| 500 | 服务器内部错误 |

---

### 4.2 通用响应格式

#### 4.2.1 成功响应
```json
{
  "success": true,
  "data": {
    // 业务数据
  },
  "message": "操作成功",
  "timestamp": 1704348000000
}
```

#### 4.2.2 错误响应
```json
{
  "success": false,
  "error": {
    "code": "INVALID_PARAMS",
    "message": "参数验证失败",
    "details": [
      {
        "field": "startYear",
        "message": "必须是整数"
      }
    ]
  },
  "timestamp": 1704348000000
}
```

#### 4.2.3 分页响应
```json
{
  "success": true,
  "data": {
    "items": [...],
    "pagination": {
      "page": 1,
      "pageSize": 20,
      "total": 150,
      "totalPages": 8
    }
  },
  "timestamp": 1704348000000
}
```

---

### 4.3 API 接口描述

#### 4.3.1 时间轴数据查询（核心接口）

**接口**：`GET /api/v1/timeline/data`

**描述**：根据视窗时间范围和缩放级别，智能返回对应密度的历史数据

**请求参数**：
```typescript
{
  startYear: number;      // 视窗起始年份（必填）
  endYear: number;        // 视窗结束年份（必填）
  viewportSpan: number;   // 视窗时间跨度（年，必填）
  civilizationIds?: string[]; // 筛选文明（可选）
}
```

**响应示例**：
```json
{
  "success": true,
  "data": {
    "civilizations": [
      {
        "id": "sinitic",
        "name": "华夏文明",
        "startYear": -2000,
        "endYear": null,
        "color": "#FFA500"
      }
    ],
    "polities": [
      {
        "id": "han",
        "name": "汉",
        "civilizationId": "sinitic",
        "startYear": -202,
        "endYear": 220,
        "color": "#FF6347",
        "importance": "high"
      }
    ],
    "persons": [
      {
        "id": "qin_shi_huang",
        "name": "秦始皇(嬴政)",
        "birthYear": -259,
        "deathYear": -210,
        "polityId": "qin",
        "importance": "high",
        "title": "皇帝"
      }
    ],
    "events": [
      {
        "id": "qin_unification",
        "name": "秦统一六国",
        "type": "point",
        "year": -221,
        "importance": "high"
      }
    ],
    "metadata": {
      "viewportSpan": 500,
      "densityLevel": "medium"
    }
  },
  "timestamp": 1704348000000
}
```

**查询逻辑**（基于视窗跨度）：

| 视窗跨度 | 返回数据 |
|----------|----------|
| > 2000年 | 文明 + 存续超过200年的政权 |
| 500-2000年 | 文明 + 所有政权 |
| 100-500年 | 文明 + 政权 + 重大持续事件（importance='high'） |
| 30-100年 | 文明 + 政权 + 持续事件 + 核心人物（importance='high'） |
| < 30年 | 完整数据（所有人物 + 所有事件） |

---

#### 4.3.2 文明相关接口

**1) 获取所有文明**

```
GET /api/v1/civilizations
```

**响应示例**：
```json
{
  "success": true,
  "data": [
    {
      "id": "sinitic",
      "name": "华夏文明",
      "startYear": -2000,
      "endYear": null,
      "color": "#FFA500",
      "description": "..."
    }
  ]
}
```

**2) 获取单个文明详情**

```
GET /api/v1/civilizations/:id
```

---

#### 4.3.3 政权相关接口

**1) 获取政权列表（支持筛选）**

```
GET /api/v1/polities?civilizationId={id}&startYear={year}&endYear={year}
```

**查询参数**：
- `civilizationId`：文明ID（可选）
- `startYear`：起始年份（可选）
- `endYear`：结束年份（可选）
- `importance`：重要程度（可选）

**2) 获取单个政权详情**

```
GET /api/v1/polities/:id
```

**响应包含**：
- 政权基本信息
- 所属文明信息
- 关联人物数量
- 关联事件数量

---

#### 4.3.4 人物相关接口

**1) 获取人物列表**

```
GET /api/v1/persons?polityId={id}&startYear={year}&endYear={year}
```

**查询参数**：
- `polityId`：政权ID（可选）
- `civilizationId`：文明ID（可选）
- `startYear`：出生年份范围起点（可选）
- `endYear`：出生年份范围终点（可选）
- `importance`：重要程度（可选）

**2) 获取单个人物详情**

```
GET /api/v1/persons/:id
```

**响应包含**：
- 人物基本信息
- 所属政权和文明信息
- 关联事件列表

---

#### 4.3.5 事件相关接口

**1) 获取事件列表**

```
GET /api/v1/events?type={point|duration}&startYear={year}&endYear={year}
```

**查询参数**：
- `type`：事件类型（可选）
- `startYear`：年份范围起点（必填）
- `endYear`：年份范围终点（必填）
- `importance`：重要程度（可选）

**2) 获取单个事件详情**

```
GET /api/v1/events/:id
```

**响应包含**：
- 事件基本信息
- 关联政权列表
- 关联人物列表

---

#### 4.3.6 搜索接口

```
GET /api/v1/search?q={keyword}&type={civilization|polity|person|event}
```

**查询参数**：
- `q`：搜索关键词（必填）
- `type`：搜索类型（可选，不传则搜索全部）

**响应示例**：
```json
{
  "success": true,
  "data": {
    "polities": [...],
    "persons": [...],
    "events": [...]
  }
}
```

---

## 5. 前端页面设计

### 5.1 组件架构

```
App
├── TimelineContainer（时间轴容器）
│   ├── ToolBar（工具栏）
│   │   ├── SearchBox（搜索框）
│   │   ├── TimeJumper（时间跳转）
│   │   └── SettingsMenu（设置菜单）
│   │
│   ├── ScaleBar（比例尺）
│   │   ├── ScaleTicks（刻度线）
│   │   └── ViewportInfo（视窗信息）
│   │
│   ├── TimelineCanvas（时间轴Canvas）
│   │   ├── CivilizationLayer（文明层）
│   │   ├── PolityLayer（政权层）
│   │   ├── PersonLayer（人物层）
│   │   └── EventLayer（事件层）
│   │
│   ├── ZoomController（缩放控制器）
│   │   ├── WheelZoomHandler（滚轮缩放）
│   │   └── DragPanHandler（拖动平移）
│   │
│   └── DetailPanel（详情面板）
│       ├── EntityCard（实体卡片）
│       └── RelatedItems（关联项）
│
└── StateManager（Redux状态管理）
    ├── timelineSlice（时间轴状态）
    ├── dataSlice（数据缓存）
    └── uiSlice（UI状态）
```

---

### 5.2 核心组件说明

#### 5.2.1 TimelineCanvas（时间轴Canvas组件）

**职责**：
- 使用 Canvas API 渲染所有历史元素
- 处理虚拟化渲染，仅绘制视窗内元素
- 响应缩放和平移事件

**核心方法**：
```typescript
class TimelineCanvas {
  // 渲染主方法
  render(viewportState: ViewportState): void;
  
  // 绘制文明层
  drawCivilizations(civilizations: Civilization[]): void;
  
  // 绘制政权层（含轨道分配）
  drawPolities(polities: Polity[]): void;
  
  // 绘制人物层
  drawPersons(persons: Person[]): void;
  
  // 绘制事件层
  drawEvents(events: Event[]): void;
  
  // 坐标转换：年份 → 像素
  yearToPixel(year: number): number;
  
  // 坐标转换：像素 → 年份
  pixelToYear(pixel: number): number;
}
```

---

#### 5.2.2 ZoomController（缩放控制器）

**职责**：
- 监听鼠标滚轮事件
- 计算缩放比例和平移偏移
- 保持鼠标指针对应的年份位置不变

**核心算法**：
```typescript
class ZoomController {
  private zoomScale: number = 1.0; // 当前缩放比例
  private offsetX: number = 0;     // 横向偏移（像素）
  
  // 处理滚轮缩放
  handleWheel(event: WheelEvent): void {
    const deltaScale = -event.deltaY * 0.001; // 缩放增量
    const mouseX = event.clientX;
    
    // 计算鼠标位置对应的年份
    const mouseYear = this.pixelToYear(mouseX);
    
    // 更新缩放比例
    const newScale = this.zoomScale * (1 + deltaScale);
    this.zoomScale = clamp(newScale, MIN_SCALE, MAX_SCALE);
    
    // 调整偏移，保持鼠标位置的年份不变
    const newMouseX = this.yearToPixel(mouseYear);
    this.offsetX += (mouseX - newMouseX);
    
    // 触发重绘
    this.requestRender();
  }
  
  // 像素转年份
  private pixelToYear(pixel: number): number {
    const viewportWidth = window.innerWidth;
    const viewportYears = BASE_YEARS / this.zoomScale;
    return this.startYear + ((pixel - this.offsetX) / viewportWidth) * viewportYears;
  }
  
  // 年份转像素
  private yearToPixel(year: number): number {
    const viewportWidth = window.innerWidth;
    const viewportYears = BASE_YEARS / this.zoomScale;
    return this.offsetX + ((year - this.startYear) / viewportYears) * viewportWidth;
  }
}
```

**缩放限制**：
- 最小缩放：视窗显示 10,000 年
- 最大缩放：视窗显示 5 年
- 缩放速度：每次滚轮改变 10-15% 缩放比例

---

#### 5.2.3 TrackAssignment（轨道分配算法）

**职责**：
- 为政权、人物、持续事件分配渲染轨道
- 避免时间重叠元素视觉冲突
- 最大化垂直空间利用率

**实现**：
```typescript
interface TimelineItem {
  id: string;
  start: number;
  end: number;
}

interface TrackAssignment {
  [itemId: string]: number; // itemId -> trackIndex
}

function assignTracks(items: TimelineItem[]): TrackAssignment {
  // 按开始时间排序
  const sorted = [...items].sort((a, b) => a.start - b.start);
  
  const tracks: Array<{ end: number }> = [];
  const assignments: TrackAssignment = {};
  
  for (const item of sorted) {
    // 寻找第一个不冲突的轨道
    let trackIndex = 0;
    while (trackIndex < tracks.length) {
      const track = tracks[trackIndex];
      if (track.end <= item.start) {
        // 无重叠，使用此轨道
        track.end = item.end;
        break;
      }
      trackIndex++;
    }
    
    // 所有
    轨道都冲突，创建新轨道
    if (trackIndex === tracks.length) {
      tracks.push({ end: item.end });
    }
    
    assignments[item.id] = trackIndex;
  }
  
  return assignments;
}
```

**算法特点**：
- 时间复杂度：O(n × m)，n为元素数量，m为轨道数量
- 贪心策略：总是选择第一个可用轨道
- 保证无重叠

---

#### 5.2.4 DataFetcher（数据获取器）

**职责**：
- 根据视窗状态智能请求数据
- 实现数据缓存策略
- 处理加载状态

**核心逻辑**：
```typescript
class DataFetcher {
  private cache = new Map<string, TimelineData>();
  
  async fetchData(viewport: ViewportState): Promise<TimelineData> {
    const cacheKey = this.getCacheKey(viewport);
    
    // 检查缓存
    if (this.cache.has(cacheKey)) {
      return this.cache.get(cacheKey)!;
    }
    
    // 请求数据
    const data = await api.get('/api/v1/timeline/data', {
      params: {
        startYear: viewport.startYear,
        endYear: viewport.endYear,
        viewportSpan: viewport.span
      }
    });
    
    // 缓存数据
    this.cache.set(cacheKey, data);
    
    return data;
  }
  
  private getCacheKey(viewport: ViewportState): string {
    return `${viewport.startYear}-${viewport.endYear}-${viewport.span}`;
  }
}
```

---

### 5.3 状态管理（Redux）

#### 5.3.1 timelineSlice（时间轴状态）

```typescript
interface TimelineState {
  zoomScale: number;          // 当前缩放比例
  offsetX: number;            // 横向偏移
  viewportSpan: number;       // 视窗时间跨度（年）
  startYear: number;          // 视窗起始年份
  endYear: number;            // 视窗结束年份
  isDragging: boolean;        // 是否正在拖动
}

const timelineSlice = createSlice({
  name: 'timeline',
  initialState,
  reducers: {
    setZoom: (state, action) => {
      state.zoomScale = action.payload;
      // 重新计算视窗跨度
      state.viewportSpan = BASE_YEARS / state.zoomScale;
    },
    setOffset: (state, action) => {
      state.offsetX = action.payload;
    },
    setDragging: (state, action) => {
      state.isDragging = action.payload;
    }
  }
});
```

---

#### 5.3.2 dataSlice（数据缓存）

```typescript
interface DataState {
  civilizations: Civilization[];
  polities: Polity[];
  persons: Person[];
  events: Event[];
  loading: boolean;
  error: string | null;
}

const dataSlice = createSlice({
  name: 'data',
  initialState,
  reducers: {
    setData: (state, action) => {
      const { civilizations, polities, persons, events } = action.payload;
      state.civilizations = civilizations;
      state.polities = polities;
      state.persons = persons;
      state.events = events;
    },
    setLoading: (state, action) => {
      state.loading = action.payload;
    },
    setError: (state, action) => {
      state.error = action.payload;
    }
  }
});
```

---

### 5.4 性能优化策略

#### 5.4.1 虚拟化渲染
```typescript
function getVisibleItems(items: TimelineItem[], viewport: ViewportState) {
  return items.filter(item => {
    // 仅返回与视窗有交集的元素
    return item.end >= viewport.startYear && item.start <= viewport.endYear;
  });
}
```

#### 5.4.2 Canvas 渲染优化
- 使用离屏 Canvas 预渲染静态内容
- 分层渲染：文明层、政权层、人物层、事件层
- 仅重绘变化区域（dirty rectangle）

#### 5.4.3 防抖与节流
```typescript
// 滚轮缩放：节流（throttle）
const handleWheel = throttle((event) => {
  // 缩放逻辑
}, 16); // 60fps

// 窗口resize：防抖（debounce）
const handleResize = debounce(() => {
  // 重新计算布局
}, 300);
```

---

## 6. 开发规范

### 6.1 代码规范

#### 6.1.1 命名规范

**变量命名**：
- 使用 camelCase：`zoomScale`、`viewportSpan`
- 布尔值使用 `is`、`has`、`can` 前缀：`isDragging`、`hasData`
- 常量使用 UPPER_SNAKE_CASE：`MAX_ZOOM_SCALE`

**函数命名**：
- 使用动词开头：`fetchData`、`renderTimeline`、`assignTracks`
- 事件处理器使用 `handle` 前缀：`handleWheel`、`handleClick`

**类命名**：
- 使用 PascalCase：`TimelineCanvas`、`ZoomController`

**文件命名**：
- 组件文件：PascalCase，如 `TimelineCanvas.tsx`
- 工具文件：camelCase，如 `trackAssignment.ts`
- 类型文件：camelCase，如 `types.ts`

**数据库命名**：
- 表名：复数形式，snake_case，如 `civilizations`、`polities`
- 字段名：snake_case，如 `start_year`、`birth_year`

---

#### 6.1.2 注释规范

**函数注释**：
```typescript
/**
 * 分配轨道给时间轴元素
 * @param items - 需要分配轨道的元素数组
 * @returns 元素ID到轨道索引的映射
 * @example
 * const tracks = assignTracks([
 *   { id: '1', start: -200, end: 220 },
 *   { id: '2', start: 220, end: 280 }
 * ]);
 */
function assignTracks(items: TimelineItem[]): TrackAssignment {
  // ...
}
```

**关键逻辑注释**：
```typescript
// 计算鼠标位置对应的年份，用于缩放时保持该年份位置不变
const mouseYear = this.pixelToYear(mouseX);
```

**TODO 注释**：
```typescript
// TODO: 优化大数据量下的渲染性能
// TODO: 添加键盘快捷键支持
```

---

### 6.2 API 规范

#### 6.2.1 请求规范
- 所有请求必须包含 `Content-Type: application/json`
- 使用标准 HTTP 方法
- 查询参数使用 camelCase
- URL 路径使用 kebab-case

#### 6.2.2 响应规范
- 统一使用标准响应格式
- 必须包含 `success` 字段
- 错误信息必须包含 `error.code` 和 `error.message`
- 时间戳使用 Unix 毫秒时间戳

#### 6.2.3 错误码规范
```typescript
enum ErrorCode {
  INVALID_PARAMS = 'INVALID_PARAMS',     // 参数错误
  NOT_FOUND = 'NOT_FOUND',               // 资源不存在
  DATABASE_ERROR = 'DATABASE_ERROR',     // 数据库错误
  INTERNAL_ERROR = 'INTERNAL_ERROR'      // 内部错误
}
```

---

### 6.3 数据库规范

#### 6.3.1 表设计规范
- 所有表必须有 `created_at` 和 `updated_at` 字段
- 主键统一使用 UUID
- 外键必须有索引
- 年份字段使用 INT 类型（支持负数）

#### 6.3.2 索引规范
- 所有年份范围查询字段必须建立联合索引
- 外键字段必须建立单列索引
- 频繁查询的字段组合建立联合索引
- 避免过多索引影响写入性能

#### 6.3.3 查询规范
```typescript
// 好的做法：使用参数化查询
const polities = await Polity.findAll({
  where: {
    start_year: { [Op.gte]: startYear },
    end_year: { [Op.lte]: endYear }
  }
});

// 避免：拼接 SQL 字符串（SQL 注入风险）
const sql = `SELECT * FROM polities WHERE start_year >= ${startYear}`;
```

---

## 附录

### A. 核心算法伪代码

#### A.1 缩放中心点计算
```
输入：
  - mouseX: 鼠标X坐标
  - currentScale: 当前缩放比例
  - newScale: 新缩放比例
  - offsetX: 当前偏移

输出：
  - newOffsetX: 新偏移

算法：
  1. mouseYear = pixelToYear(mouseX, currentScale, offsetX)
  2. newMouseX = yearToPixel(mouseYear, newScale, offsetX)
  3. newOffsetX = offsetX + (mouseX - newMouseX)
  4. return newOffsetX
```

#### A.2 视窗数据查询决策树
```
if (viewportSpan > 2000) {
  return {
    civilizations: all,
    polities: duration > 200 years,
    persons: none,
    events: none
  }
} else if (viewportSpan > 500) {
  return {
    civilizations: all,
    polities: all,
    persons: none,
    events: none
  }
} else if (viewportSpan > 100) {
  return {
    civilizations: all,
    polities: all,
    persons: none,
    events: duration events (importance = high)
  }
} else if (viewportSpan > 30) {
  return {
    civilizations: all,
    polities: all,
    persons: importance = high,
    events: duration events (all)
  }
} else {
  return {
    civilizations: all,
    polities: all,
    persons: all,
    events: all
  }
}
```

---

### B. 示例数据

#### B.1 华夏文明示例数据
```json
{
  "civilization": {
    "id": "sinitic",
    "name": "华夏文明",
    "startYear": -2000,
    "endYear": null,
    "color": "#FFA500"
  },
  "polities": [
    { "id": "qin", "name": "秦", "startYear": -221, "endYear": -206, "importance": "high" },
    { "id": "han", "name": "汉", "startYear": -202, "endYear": 220, "importance": "high" },
    { "id": "tang", "name": "唐", "startYear": 618, "endYear": 907, "importance": "high" }
  ],
  "persons": [
    {
      "id": "qin_shi_huang",
      "name": "秦始皇",
      "birthYear": -259,
      "deathYear": -210,
      "polityId": "qin",
      "importance": "high",
      "title": "皇帝"
    }
  ],
  "events": [
    {
      "id": "qin_unification",
      "name": "秦统一六国",
      "type": "point",
      "year": -221,
      "importance": "high"
    }
  ]
}
```

---

### C. 环境配置

#### C.1 开发环境变量（`.env.development`）
```bash
# API配置
VITE_API_BASE_URL=http://localhost:3000/api/v1

# 数据库配置
DB_HOST=localhost
DB_PORT=3306
DB_NAME=history_timezone
DB_USER=root
DB_PASSWORD=password

# 服务器配置
PORT=3000
NODE_ENV=development
```

#### C.2 生产环境变量（`.env.production`）
```bash
VITE_API_BASE_URL=https://api.historytimezone.com/api/v1

DB_HOST=production-db-host
DB_PORT=3306
DB_NAME=history_timezone_prod
DB_USER=prod_user
DB_PASSWORD=secure_password

PORT=3000
NODE_ENV=production
```

---

**文档版本**: v1.0  
**创建日期**: 2026-01-04  
**最后更新**: 2026-01-04  
**维护人员**: 开发团队